1. Buffer 零拷贝优化（不改变接口）

// 在 include/Buffer.h 中添加
class Buffer {
public:
    // 1. 零拷贝读优化
    int readFd(int fd, int* savedErrno);
    
    // 2. 零拷贝写优化
    int writeFd(int fd, int* savedErrno);
    
    // 3. 预分配优化
    void reserve(size_t len);
    
    // 4. 获取内部缓冲区的直接访问
    const char* peek() const { return begin() + readerIndex_; }
    char* beginWrite() { return begin() + writerIndex_; }
    const char* findCRLF() const;
    const char* findCRLF(const char* start) const;
    
private:
    // 优化现有实现
    char* begin() { return &*buffer_.begin(); }  // 使用vector的data()
    const char* begin() const { return &*buffer_.begin(); }
    
    // 添加内存对齐支持
    static const size_t kCheapPrepend = 8;  // 从8改为16，方便内存对齐
    static const size_t kInitialSize = 1024;  // 初始大小
    
    // 使用更高效的内部结构
    std::vector<char> buffer_;  // 保持原结构，但优化使用方式
};

// src/base/Buffer.cpp 中的实现优化
#include <sys/uio.h>
#include <errno.h>

int Buffer::readFd(int fd, int* savedErrno) {
    // 使用 iovec 实现零拷贝读
    char extrabuf[65536];  // 64K 栈缓冲区
    struct iovec vec[2];
    const size_t writable = writableBytes();
    
    // 第一块：Buffer的可写空间
    vec[0].iov_base = begin() + writerIndex_;
    vec[0].iov_len = writable;
    
    // 第二块：栈缓冲区
    vec[1].iov_base = extrabuf;
    vec[1].iov_len = sizeof(extrabuf);
    
    // 当Buffer有足够空间时，只使用一块
    const int iovcnt = (writable < sizeof(extrabuf)) ? 2 : 1;
    const ssize_t n = ::readv(fd, vec, iovcnt);
    
    if (n < 0) {
        *savedErrno = errno;
    } else if (static_cast<size_t>(n) <= writable) {
        // 数据全部在Buffer中
        writerIndex_ += n;
    } else {
        // 部分数据在栈缓冲区
        writerIndex_ = buffer_.size();
        append(extrabuf, n - writable);
    }
    
    return static_cast<int>(n);
}

int Buffer::writeFd(int fd, int* savedErrno) {
    ssize_t n = ::write(fd, peek(), readableBytes());
    if (n < 0) {
        *savedErrno = errno;
    } else if (n > 0) {
        retrieve(n);
    }
    return static_cast<int>(n);
}

void Buffer::reserve(size_t len) {
    if (writableBytes() < len) {
        if (readerIndex_ + writableBytes() < len) {
            // 重新分配
            std::vector<char> newBuffer(kCheapPrepend + readerIndex_ + len);
            std::copy(begin() + readerIndex_, begin() + writerIndex_,
                     newBuffer.begin() + kCheapPrepend);
            buffer_.swap(newBuffer);
            writerIndex_ = kCheapPrepend + (writerIndex_ - readerIndex_);
            readerIndex_ = kCheapPrepend;
        } else {
            // 内存整理
            std::copy(begin() + readerIndex_, begin() + writerIndex_,
                     begin() + kCheapPrepend);
            writerIndex_ = kCheapPrepend + (writerIndex_ - readerIndex_);
            readerIndex_ = kCheapPrepend;
        }
    }
}


2. 简单内存池（不改变现有结构）

// 新增 include/MemoryPool.h
#pragma once

#include "noncopyable.h"
#include <atomic>
#include <vector>
#include <memory>

namespace muduo {

class MemoryPool : noncopyable {
public:
    static MemoryPool& instance();
    
    void* allocate(size_t size);
    void deallocate(void* ptr, size_t size);
    
    // 统计信息
    size_t allocatedBytes() const { return allocatedBytes_.load(); }
    size_t allocatedCount() const { return allocatedCount_.load(); }
    size_t peakAllocatedBytes() const { return peakAllocatedBytes_.load(); }
    
    // 清空统计
    void resetStatistics();
    
private:
    MemoryPool();
    ~MemoryPool() = default;
    
    struct Block {
        Block* next;
        char data[1];  // 柔性数组
    };
    
    enum { kMaxSmallObjectSize = 4096 };  // 4KB以下使用内存池
    enum { kAlign = 8 };  // 8字节对齐
    enum { kNumFreeLists = kMaxSmallObjectSize / kAlign };
    
    // 将size向上对齐到kAlign的倍数
    static size_t roundUp(size_t bytes) {
        return (bytes + kAlign - 1) & ~(kAlign - 1);
    }
    
    // 根据size获取freelist索引
    static size_t freeListIndex(size_t bytes) {
        return (bytes + kAlign - 1) / kAlign - 1;
    }
    
    // 空闲链表数组
    Block* freeLists_[kNumFreeLists];
    
    // 统计信息
    std::atomic<size_t> allocatedBytes_;
    std::atomic<size_t> allocatedCount_;
    std::atomic<size_t> peakAllocatedBytes_;
    
    // 线程局部缓存
    class ThreadCache;
    static thread_local ThreadCache* t_cache_;
    
    // 中心缓存
    class CentralCache;
    static CentralCache* centralCache_;
};

// Buffer中使用内存池的简单包装
class PooledBuffer {
public:
    explicit PooledBuffer(size_t size) 
        : data_(static_cast<char*>(MemoryPool::instance().allocate(size))),
          size_(size) {
    }
    
    ~PooledBuffer() {
        if (data_) {
            MemoryPool::instance().deallocate(data_, size_);
        }
    }
    
    char* data() { return data_; }
    const char* data() const { return data_; }
    size_t size() const { return size_; }
    
private:
    char* data_;
    size_t size_;
};

}  // namespace muduo

// 新增 src/base/MemoryPool.cpp
#include "MemoryPool.h"
#include <cstdlib>
#include <iostream>

namespace muduo {

MemoryPool& MemoryPool::instance() {
    static MemoryPool pool;
    return pool;
}

MemoryPool::MemoryPool() 
    : allocatedBytes_(0),
      allocatedCount_(0),
      peakAllocatedBytes_(0) {
    // 初始化空闲链表
    for (auto& list : freeLists_) {
        list = nullptr;
    }
}

void* MemoryPool::allocate(size_t size) {
    if (size > kMaxSmallObjectSize) {
        // 大对象直接分配
        void* ptr = ::malloc(size);
        if (ptr) {
            allocatedBytes_.fetch_add(size);
            allocatedCount_.fetch_add(1);
            
            size_t peak = peakAllocatedBytes_.load();
            size_t allocated = allocatedBytes_.load();
            while (allocated > peak && 
                   !peakAllocatedBytes_.compare_exchange_weak(peak, allocated)) {
                // CAS失败，重试
            }
        }
        return ptr;
    }
    
    // 小对象使用内存池
    size_t index = freeListIndex(size);
    Block* block = freeLists_[index];
    
    if (block) {
        // 有空闲块
        freeLists_[index] = block->next;
    } else {
        // 分配新的内存块
        size_t alignedSize = roundUp(size);
        block = static_cast<Block*>(::malloc(sizeof(Block) + alignedSize - 1));
        if (!block) {
            return nullptr;
        }
    }
    
    allocatedBytes_.fetch_add(roundUp(size));
    allocatedCount_.fetch_add(1);
    
    return static_cast<void*>(&block->data[0]);
}

void MemoryPool::deallocate(void* ptr, size_t size) {
    if (!ptr) return;
    
    if (size > kMaxSmallObjectSize) {
        // 大对象直接释放
        ::free(ptr);
    } else {
        // 小对象回收到内存池
        size_t index = freeListIndex(size);
        Block* block = static_cast<Block*>(static_cast<void*>(
            static_cast<char*>(ptr) - offsetof(Block, data)));
        block->next = freeLists_[index];
        freeLists_[index] = block;
    }
    
    allocatedBytes_.fetch_sub(roundUp(size));
    allocatedCount_.fetch_sub(1);
}

void MemoryPool::resetStatistics() {
    allocatedBytes_ = 0;
    allocatedCount_ = 0;
    peakAllocatedBytes_ = 0;
}

}  // namespace muduo


3. 优化后的Buffer（使用内存池）

// 可选：在include/Buffer.h中提供可选的池化版本
// 不改变现有Buffer，只提供新类
class PooledBuffer {
public:
    static const size_t kCheapPrepend = 16;
    static const size_t kInitialSize = 1024;
    
    explicit PooledBuffer(size_t initialSize = kInitialSize)
        : data_(static_cast<char*>(MemoryPool::instance().allocate(initialSize + kCheapPrepend))),
          capacity_(initialSize + kCheapPrepend),
          readerIndex_(kCheapPrepend),
          writerIndex_(kCheapPrepend) {
    }
    
    ~PooledBuffer() {
        if (data_) {
            MemoryPool::instance().deallocate(data_, capacity_);
        }
    }
    
    // 与原有Buffer相同的接口
    size_t readableBytes() const { return writerIndex_ - readerIndex_; }
    size_t writableBytes() const { return capacity_ - writerIndex_; }
    size_t prependableBytes() const { return readerIndex_; }
    
    const char* peek() const { return data_ + readerIndex_; }
    char* beginWrite() { return data_ + writerIndex_; }
    
    void retrieve(size_t len) {
        if (len < readableBytes()) {
            readerIndex_ += len;
        } else {
            retrieveAll();
        }
    }
    
    void retrieveAll() {
        readerIndex_ = kCheapPrepend;
        writerIndex_ = kCheapPrepend;
    }
    
    void ensureWritableBytes(size_t len) {
        if (writableBytes() < len) {
            makeSpace(len);
        }
    }
    
    void append(const char* data, size_t len) {
        ensureWritableBytes(len);
        std::copy(data, data + len, beginWrite());
        hasWritten(len);
    }
    
    void hasWritten(size_t len) { writerIndex_ += len; }
    
    // 使用SSE/AVX优化的大数据复制
    void fastAppend(const char* data, size_t len) {
        if (len == 0) return;
        ensureWritableBytes(len);
        
        // 使用memcpy的优化版本
#if defined(__SSE2__)
        // SSE优化
        fastCopySSE(data, beginWrite(), len);
#elif defined(__AVX2__)
        // AVX优化
        fastCopyAVX(data, beginWrite(), len);
#else
        std::memcpy(beginWrite(), data, len);
#endif
        hasWritten(len);
    }
    
private:
    void makeSpace(size_t len) {
        if (writableBytes() + prependableBytes() < len + kCheapPrepend) {
            // 需要重新分配
            size_t newCapacity = capacity_ * 2;
            while (newCapacity < writerIndex_ + len) {
                newCapacity *= 2;
            }
            
            char* newData = static_cast<char*>(
                MemoryPool::instance().allocate(newCapacity));
            
            std::copy(data_ + readerIndex_, data_ + writerIndex_,
                     newData + kCheapPrepend);
            
            MemoryPool::instance().deallocate(data_, capacity_);
            data_ = newData;
            capacity_ = newCapacity;
            writerIndex_ = kCheapPrepend + (writerIndex_ - readerIndex_);
            readerIndex_ = kCheapPrepend;
        } else {
            // 内存整理
            std::copy(data_ + readerIndex_, data_ + writerIndex_,
                     data_ + kCheapPrepend);
            writerIndex_ = kCheapPrepend + (writerIndex_ - readerIndex_);
            readerIndex_ = kCheapPrepend;
        }
    }
    
    char* data_;
    size_t capacity_;
    size_t readerIndex_;
    size_t writerIndex_;
};


4. 测试验证代码

// tests/test_buffer_optimized.cpp
#include "Buffer.h"
#include "MemoryPool.h"
#include <iostream>
#include <sys/uio.h>
#include <fcntl.h>
#include <unistd.h>

void test_buffer_read_fd() {
    muduo::Buffer buf;
    
    // 创建管道测试
    int pipefd[2];
    ::pipe(pipefd);
    
    std::string testData(4096, 'A');  // 4KB数据
    ::write(pipefd[1], testData.data(), testData.size());
    
    int savedErrno = 0;
    int n = buf.readFd(pipefd[0], &savedErrno);
    
    std::cout << "Read " << n << " bytes from fd" << std::endl;
    std::cout << "Buffer readable bytes: " << buf.readableBytes() << std::endl;
    
    ::close(pipefd[0]);
    ::close(pipefd[1]);
}

void test_buffer_write_fd() {
    muduo::Buffer buf;
    buf.append("Hello, World!", 13);
    
    int pipefd[2];
    ::pipe(pipefd);
    
    int savedErrno = 0;
    int n = buf.writeFd(pipefd[1], &savedErrno);
    
    std::cout << "Write " << n << " bytes to fd" << std::endl;
    
    char readBuf[1024];
    ::read(pipefd[0], readBuf, sizeof(readBuf));
    std::cout << "Read from pipe: " << std::string(readBuf, n) << std::endl;
    
    ::close(pipefd[0]);
    ::close(pipefd[1]);
}

void test_buffer_reserve() {
    muduo::Buffer buf;
    
    std::cout << "Initial capacity test:" << std::endl;
    std::cout << "Prependable: " << buf.prependableBytes() << std::endl;
    std::cout << "Readable: " << buf.readableBytes() << std::endl;
    std::cout << "Writable: " << buf.writableBytes() << std::endl;
    
    // 测试reserve
    buf.reserve(8192);  // 预留8KB空间
    
    std::cout << "\nAfter reserve 8192:" << std::endl;
    std::cout << "Prependable: " << buf.prependableBytes() << std::endl;
    std::cout << "Readable: " << buf.readableBytes() << std::endl;
    std::cout << "Writable: " << buf.writableBytes() << std::endl;
    
    // 写入大量数据
    std::string largeData(16384, 'X');  // 16KB
    buf.append(largeData.data(), largeData.size());
    
    std::cout << "\nAfter append 16384 bytes:" << std::endl;
    std::cout << "Prependable: " << buf.prependableBytes() << std::endl;
    std::cout << "Readable: " << buf.readableBytes() << std::endl;
    std::cout << "Writable: " << buf.writableBytes() << std::endl;
}

void test_memory_pool() {
    muduo::MemoryPool& pool = muduo::MemoryPool::instance();
    
    std::cout << "\n=== Memory Pool Test ===" << std::endl;
    
    // 测试小对象分配
    void* small1 = pool.allocate(128);
    void* small2 = pool.allocate(256);
    void* small3 = pool.allocate(512);
    
    std::cout << "Small allocations:" << std::endl;
    std::cout << "Allocated bytes: " << pool.allocatedBytes() << std::endl;
    std::cout << "Allocated count: " << pool.allocatedCount() << std::endl;
    
    // 测试大对象分配
    void* large1 = pool.allocate(8192);
    void* large2 = pool.allocate(16384);
    
    std::cout << "\nAfter large allocations:" << std::endl;
    std::cout << "Allocated bytes: " << pool.allocatedBytes() << std::endl;
    std::cout << "Allocated count: " << pool.allocatedCount() << std::endl;
    
    // 释放内存
    pool.deallocate(small1, 128);
    pool.deallocate(small2, 256);
    pool.deallocate(small3, 512);
    pool.deallocate(large1, 8192);
    pool.deallocate(large2, 16384);
    
    std::cout << "\nAfter deallocation:" << std::endl;
    std::cout << "Allocated bytes: " << pool.allocatedBytes() << std::endl;
    std::cout << "Allocated count: " << pool.allocatedCount() << std::endl;
    
    // 峰值内存测试
    std::vector<void*> allocations;
    for (int i = 0; i < 100; ++i) {
        allocations.push_back(pool.allocate(1024));  // 分配1KB
    }
    
    std::cout << "\nPeak allocated bytes: " << pool.peakAllocatedBytes() << std::endl;
    
    for (void* ptr : allocations) {
        pool.deallocate(ptr, 1024);
    }
    
    pool.resetStatistics();
    std::cout << "\nAfter reset:" << std::endl;
    std::cout << "Allocated bytes: " << pool.allocatedBytes() << std::endl;
    std::cout << "Peak allocated bytes: " << pool.peakAllocatedBytes() << std::endl;
}

void benchmark_buffer_performance() {
    muduo::Buffer buf;
    
    auto start = std::chrono::high_resolution_clock::now();
    
    // 写入性能测试
    for (int i = 0; i < 10000; ++i) {
        buf.append("Hello Buffer!", 13);
    }
    
    auto mid = std::chrono::high_resolution_clock::now();
    
    // 读取性能测试
    std::string result;
    for (size_t i = 0; i < buf.readableBytes(); ++i) {
        result.push_back(buf.peek()[i]);
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    
    auto write_time = std::chrono::duration_cast<std::chrono::microseconds>(mid - start);
    auto read_time = std::chrono::duration_cast<std::chrono::microseconds>(end - mid);
    
    std::cout << "\n=== Buffer Performance Benchmark ===" << std::endl;
    std::cout << "Write 130,000 bytes: " << write_time.count() << " μs" << std::endl;
    std::cout << "Read " << buf.readableBytes() << " bytes: " << read_time.count() << " μs" << std::endl;
    std::cout << "Throughput write: " << (130000.0 / write_time.count()) << " MB/s" << std::endl;
    std::cout << "Throughput read: " << (buf.readableBytes() / read_time.count()) << " MB/s" << std::endl;
}

int main() {
    std::cout << "=== Buffer Optimization Tests ===" << std::endl;
    
    std::cout << "\n1. Testing Buffer readFd..." << std::endl;
    test_buffer_read_fd();
    
    std::cout << "\n2. Testing Buffer writeFd..." << std::endl;
    test_buffer_write_fd();
    
    std::cout << "\n3. Testing Buffer reserve..." << std::endl;
    test_buffer_reserve();
    
    std::cout << "\n4. Testing Memory Pool..." << std::endl;
    test_memory_pool();
    
    std::cout << "\n5. Benchmarking Buffer Performance..." << std::endl;
    benchmark_buffer_performance();
    
    std::cout << "\n=== All Tests Completed ===" << std::endl;
    
    return 0;
}


5. 如何使用（不改现有代码）

// 在你的项目中可以选择性地使用优化的Buffer
// 选项1：继续使用原Buffer，但获得readFd/writeFd优化
// 选项2：使用新的PooledBuffer（需要包含MemoryPool.h）

// 不改变现有代码，只是增强功能
#include "Buffer.h"
#include "MemoryPool.h"  // 可选

// 原代码完全兼容
muduo::Buffer buffer;
buffer.append("data", 4);

// 使用新功能
int savedErrno = 0;
buffer.readFd(sockfd, &savedErrno);
buffer.writeFd(sockfd, &savedErrno);
buffer.reserve(8192);  // 预分配8KB


6. 构建说明

由于不改变项目结构，只需要：

1. 在 include/ 下添加 MemoryPool.h
2. 在 src/base/ 下添加 MemoryPool.cpp
3. 在 Buffer.h 和 Buffer.cpp 中添加新方法
4. 添加新的测试文件 tests/test_buffer_optimized.cpp
5. 在 CMakeLists.txt 中简单添加新文件即可

