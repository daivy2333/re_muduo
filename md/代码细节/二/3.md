

## 一、生命周期管理

### 1. TcpConnection 的状态变迁

`TcpConnection` 定义了以下状态（通常在 `enum StateE` 中）：

| 状态 | 含义 | 触发条件 |
|------|------|--------|
| **`kConnecting`** | 连接正在建立（客户端） | 构造时初始状态（客户端） |
| **`kConnected`** | 连接已建立，可正常通信 | • 服务端：`connectEstablished()` 被调用<br>• 客户端：`connect()` 成功后调用 `connectEstablished()` |
| **`kDisconnecting`** | 正在关闭（应用层发起） | 调用 `shutdown()` 或 `forceClose()` |
| **`kDisconnected`** | 连接已完全关闭 | TCP 四次挥手完成，或对端关闭 |

#### ▶ 状态变迁流程（以服务端为例）：
1. **建立**：  
   - `Acceptor` 接收新连接 → `TcpServer::newConnection()`  
   - 创建 `TcpConnection` 对象（初始状态为 `kConnecting`）  
   - 通过 `EventLoop::runInLoop()` 调用 `connectEstablished()` → **切换到 `kConnected`**  
   - 触发 `connectionCallback_(shared_from_this(), true)`

2. **关闭（主动）**：  
   - 用户调用 `shutdown()` → 设置状态为 `kDisconnecting`  
   - 调用 `::shutdown(fd, SHUT_WR)`（半关闭）  
   - 当 output buffer 清空且收到对端 FIN 后 → 切换到 `kDisconnected`

3. **关闭（被动）**：  
   - 对端关闭 → `EPOLLIN` 事件触发 `handleRead()`  
   - `read()` 返回 0（EOF）→ 调用 `handleClose()`  
   - 设置状态为 `kDisconnected`，触发 `connectionCallback_(..., false)`

> ✅ **关键点**：状态变更由 **I/O 事件** 或 **用户 API 调用** 驱动，全部在 **IO 线程** 中完成。

---

### 2. 析构函数职责与 Channel 生命周期管理

#### ▶ `TcpConnection` 析构函数需做什么？
- **不直接 close socket**！因为：
  - 可能还有数据未发送完；
  - 应优先调用 `shutdown()` 半关闭，优雅关闭。
- 实际析构通常发生在 `kDisconnected` 状态，此时：
  - `Socket` 成员析构 → 自动 `::close(fd)`
  - `Channel` 成员析构 → 自动从 `Poller` 注销（通过 RAII）

#### ▶ 为什么说 “Channel 生命周期由 TcpConnection 管理”？
- `TcpConnection` **持有 `Channel` 的唯一所有权**（通常是 `std::unique_ptr<Channel>` 或成员对象）；
- `Channel` 的生命周期严格等于 `TcpConnection`：
  - 构造时创建 `Channel`，注册到 `EventLoop`；
  - 析构时 `Channel` 自动注销（`~Channel()` 调用 `remove()`）；
- 这保证了：**只要 `TcpConnection` 存在，其 `Channel` 就有效；一旦销毁，事件监听立即停止**。

> 🔍 注意：`TcpConnection` 通常用 `shared_ptr` 管理（支持跨线程引用），其析构由引用计数决定，但 **所有状态变更和资源释放仍在 IO 线程完成**。

---

## 二、数据读写机制

### 1. 可读事件处理流程（socket → inputBuffer_ → user）

当 `EPOLLIN` 触发时：

```cpp
void TcpConnection::handleRead(Timestamp receiveTime) {
  ssize_t n = inputBuffer_.readFd(channel_->fd(), &savedErrno_);
  if (n > 0) {
    messageCallback_(shared_from_this(), &inputBuffer_, receiveTime);
  } else if (n == 0) {
    handleClose(); // 对端关闭
  } else {
    handleError();
  }
}
```

#### ▶ 关键步骤：
1. **高效读取**：`Buffer::readFd()` 使用栈上临时缓冲区 + `readv()`，避免额外拷贝；
2. **数据存入 `inputBuffer_`**：自动扩容（`makeSpace`）；
3. **回调用户**：`messageCallback_` 被调用，传入 `inputBuffer_` 引用；
4. **用户消费数据**：通常调用 `buffer->retrieve(...)` 移除已处理数据。

> ✅ **优势**：`Buffer` 解耦了“网络读取”和“业务解析”，用户可按协议（如 LineBased、LengthField）逐步消费。

---

### 2. `send()` 与输出缓冲区管理 + 高水位控制

#### ▶ `send()` 流程：
```cpp
void TcpConnection::send(const std::string& message) {
  if (state_ == kConnected) {
    if (loop_->isInLoopThread()) {
      sendInLoop(message);
    } else {
      loop_->runInLoop([=]() { sendInLoop(message); });
    }
  }
}
```

#### ▶ `sendInLoop()` 逻辑：
1. 若 **output buffer 为空** 且 socket 可写 → 直接 `::write()`；
2. 否则 → **追加到 `outputBuffer_`**；
3. **启用写事件监听**：`channel_->enableWriting()`（此前可能 disabled）；
4. 下次 `EPOLLOUT` 触发 `handleWrite()`，继续发送剩余数据。

#### ▶ `highWaterMarkCallback_` 的作用：
- 当 `outputBuffer_` 大小超过阈值（如 64KB）时触发；
- 用于 **流量控制**：通知上层“发送过快，请暂停”；
- 示例：
  ```cpp
  if (outputBuffer_.readableBytes() > highWaterMark_) {
    if (highWaterMarkCallback_) {
      highWaterMarkCallback_(shared_from_this(), outputBuffer_.readableBytes());
    }
  }
  ```
- 用户可在回调中调用 `stopSend()` 或降低发送频率。

> ✅ **设计意义**：防止内存无限增长（如对端接收慢），实现背压（backpressure）。

---

### 3. 连接关闭机制：`shutdown()` vs `close()`

#### ▶ 两种关闭方式：
| 方式 | 系统调用 | 行为 | 用途 |
|------|--------|------|------|
| **`shutdown(SHUT_WR)`** | 半关闭 | 发送 FIN，不再发送数据，但仍可接收 | 优雅关闭（等对端确认） |
| **`close()`** | 全关闭 | 立即释放 fd，可能丢弃未发送数据 | 强制关闭（如出错） |

#### ▶ 在 `TcpConnection` 中的使用：
- **`TcpConnection::shutdown()`**（用户调用）：
  ```cpp
  void TcpConnection::shutdown() {
    if (state_ == kConnected) {
      setState(kDisconnecting);
      loop_->runInLoop(std::bind(&TcpConnection::shutdownInLoop, this));
    }
  }

  void TcpConnection::shutdownInLoop() {
    if (!channel_->isWriting()) { // output buffer 已空
      socket_->shutdownWrite(); // ← ::shutdown(fd, SHUT_WR)
    }
  }
  ```
  - 等待 output buffer 清空后再 `shutdownWrite()`；
  - 对端收到 FIN 后会关闭，触发本端 `handleRead()`（返回 0）→ `handleClose()`。

- **析构函数**：
  - 不主动调用 `shutdown()`；
  - 依赖 `Socket` 析构 → `::close(fd)`；
  - 但通常在 `kDisconnected` 状态才析构，所以 `close()` 只是释放资源。

> ✅ **最佳实践**：  
> - 正常关闭用 `shutdown()`（优雅）；  
> - 异常关闭用 `forceClose()`（直接 `close()`）。

---

## 总结回答（面试口语化精简版）

> “`TcpConnection` 有四个状态：`kConnecting`（初始）、`kConnected`（建立成功）、`kDisconnecting`（正在关闭）、`kDisconnected`（已关闭）。状态由 I/O 事件（如对端关闭）或用户调用（如 `shutdown()`）触发，全部在 IO 线程中变更。
>
> 析构时，`TcpConnection` 依赖 `Socket` 和 `Channel` 的 RAII 自动清理资源。`Channel` 由 `TcpConnection` 持有，确保其生命周期一致——连接存在时监听事件，销毁时自动注销。
>
> 读数据时，`handleRead()` 通过 `Buffer::readFd()` 高效读入 `inputBuffer_`，再通过 `messageCallback_` 交给用户；用户消费后调用 `retrieve()` 移除数据。
>
> 写数据时，若一次没发完，剩余数据缓存在 `outputBuffer_`，并启用 `EPOLLOUT` 事件。下次可写时继续发送。`highWaterMarkCallback_` 在缓冲区过大时触发，用于流量控制。
>
> 关闭连接时，`shutdown()` 先半关闭（`SHUT_WR`），等数据发完再彻底关闭；而析构时直接 `close()`，但通常只在连接已断开后才析构，避免数据丢失。”

