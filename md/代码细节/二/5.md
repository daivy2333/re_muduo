

## 一、连接建立机制

### 1. Acceptor 的职责与内部结构

#### ▶ 主要职责：
- **创建并管理监听 socket（listen fd）**；
- **将 listen fd 注册到 EventLoop 的事件循环中**；
- **在新连接到达时，接受连接并通知上层（TcpServer）**。

#### ▶ 内部是否有 Channel？监听哪个 socket？
- **是的，Acceptor 拥有自己的 `Channel`**，绑定 **listen socket fd**；
- 该 `Channel` 监听 **`EPOLLIN` 事件**（即“有新连接可 accept”）；
- 回调设置为 `Acceptor::handleRead()`。

```cpp
// Acceptor.cpp 构造函数
Acceptor::Acceptor(EventLoop* loop, const InetAddress& listenAddr)
  : loop_(loop),
    acceptSocket_(createNonblockingOrDie(listenAddr.family())),
    acceptChannel_(loop, acceptSocket_.fd())
{
  acceptSocket_.bindAddress(listenAddr);
  acceptSocket_.listen();
  acceptChannel_.setReadCallback(
    std::bind(&Acceptor::handleRead, this));
  acceptChannel_.enableReading(); // ← 注册 EPOLLIN
}
```

> ✅ **关键点**：Acceptor 的 `Channel` 生命周期由 Acceptor 自身管理，且只用于监听 **listen fd**，不处理数据 I/O。

---

### 2. 新连接到达时的处理流程（`Acceptor::handleRead()`）

当 `EPOLLIN` 触发时：

```cpp
void Acceptor::handleRead() {
  InetAddress peerAddr;
  int connfd = acceptSocket_.accept(&peerAddr); // ← 接受新连接
  if (connfd >= 0) {
    if (newConnectionCallback_) {
      newConnectionCallback_(connfd, peerAddr); // ← 通知 TcpServer
    } else {
      ::close(connfd);
    }
  }
}
```

#### ▶ 关键步骤：
1. **调用 `accept()`** 获取新连接的 socket fd（`connfd`）和对端地址；
2. **通过 `newConnectionCallback_` 回调** 将 `connfd` 传递给 `TcpServer`；
3. **`TcpServer` 负责创建 `TcpConnection`**：
   - 选择一个工作线程的 `EventLoop`；
   - 在该线程中构造 `TcpConnection` 对象；
   - 将 `connfd` 交由 `TcpConnection` 管理。

> 🔍 注意：`Acceptor` **不直接创建 `TcpConnection`**，而是通过回调委托给 `TcpServer`，实现解耦。

---

## 二、多线程服务模型

### 1. TcpServer 如何使用 EventLoopThreadPool？

#### ▶ 整体架构：
- `TcpServer` 持有一个 `EventLoopThreadPool`（线程池）；
- 主线程运行 `mainReactor`（含 `Acceptor`）；
- 工作线程运行 `subReactors`（每个线程一个 `EventLoop`）；
- 新连接由主线程接收，**分配给某个工作线程处理**。

#### ▶ `getNextLoop()` 的选择策略：
- **默认采用轮询（round-robin）**：
  ```cpp
  // EventLoopThreadPool.cpp
  EventLoop* EventLoopThreadPool::getNextLoop() {
    EventLoop* loop = baseLoop_; // 默认用主线程（若未启用线程池）
    if (!loops_.empty()) {
      loop = loops_[next_]; // ← 轮询
      next_ = (next_ + 1) % loops_.size();
    }
    return loop;
  }
  ```
- 也可扩展为哈希（如按 client IP）或随机策略。

#### ▶ 新连接分配流程：
```cpp
// TcpServer::newConnection()
void TcpServer::newConnection(int sockfd, const InetAddress& peerAddr) {
  EventLoop* ioLoop = threadPool_->getNextLoop(); // ← 选择工作线程
  char buf[64];
  snprintf(buf, sizeof buf, ":%s#%d", ipPort.c_str(), nextConnId_);
  ++nextConnId_;
  string connName = name_ + buf;

  // 在目标线程中创建 TcpConnection
  ioLoop->runInLoop(
    std::bind(&TcpServer::newConnectionInLoop, this,
              ioLoop, sockfd, peerAddr, connName));
}
```

> ✅ **优势**：连接均匀分布，每个连接的 I/O 在固定线程处理，**无锁**。

---

### 2. 用户回调的执行线程与线程安全保证

#### ▶ 回调执行线程：
- **所有用户回调（`connectionCallback_`, `messageCallback_` 等）都在 `TcpConnection` 所属的 IO 线程中执行**；
- 即：哪个工作线程的 `EventLoop` 管理该连接，就在哪个线程调用回调。

#### ▶ 如何保证线程安全？
1. **串行化执行**：
   - 每个 `EventLoop` 是单线程事件循环；
   - 所有 I/O 事件和回调在该线程**串行执行**，无需加锁。
2. **资源归属明确**：
   - `TcpConnection`、`Buffer`、`Channel` 等对象**只在所属 IO 线程访问**；
   - 用户回调可安全访问这些对象（如 `conn->send()`）。
3. **跨线程操作通过 `runInLoop()`**：
   - 若其他线程需操作连接，必须通过 `conn->getLoop()->runInLoop()` 提交任务；
   - 保证操作在正确线程执行。

> ⚠️ **重要约束**：用户回调**不能阻塞**，否则会阻塞整个 EventLoop，影响其他连接。

---

## 总结回答（面试口语化精简版）

> “`Acceptor` 负责监听新连接，它内部持有一个 `Channel`，绑定 listen socket，并监听 `EPOLLIN` 事件。当新连接到达时，`handleRead()` 调用 `accept()` 获取 connfd，并通过回调通知 `TcpServer`。
>
> `TcpServer` 使用 `EventLoopThreadPool` 实现多线程：主线程接收连接，工作线程处理 I/O。`getNextLoop()` 默认用轮询策略选择工作线程，确保负载均衡。
>
> 所有用户回调（如 `messageCallback_`）都在 `TcpConnection` 所属的 IO 线程中执行。由于每个连接的生命周期和数据完全由一个线程管理，无需加锁，天然线程安全。跨线程操作必须通过 `runInLoop()` 提交任务。”

