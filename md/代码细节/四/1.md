

## 一、单元测试策略

### 1. 如何为 `EventLoop` 等事件驱动组件编写单元测试？

事件驱动组件（如 `EventLoop`、`Channel`）的难点在于：**行为依赖异步事件和时间推进**。我们的测试策略是：

#### ▶ 核心方法：**控制事件循环 + 模拟事件触发**
- **在测试线程中运行 `EventLoop`**（通常用 `EventLoopThread`）；
- **通过 `runInLoop()` 提交任务**，验证执行顺序；
- **使用 `eventfd` 或 `socketpair` 模拟 I/O 事件**；
- **设置超时机制**，防止测试 hang 住。

#### ▶ 示例：`test_eventloop.cpp` 中的测试
```cpp
// test_eventloop_channel
TEST(EventLoopTest, Channel) {
  EventLoop loop;
  int fd[2];
  ::socketpair(AF_UNIX, SOCK_STREAM, 0, fd); // 创建通信对

  Channel channel(&loop, fd[0]);
  channel.setReadCallback([&loop]() { loop.quit(); });
  channel.enableReading();

  // 在另一个线程写入数据，触发 EPOLLIN
  std::thread t([fd]() {
    char c = 'x';
    ::write(fd[1], &c, 1);
  });

  loop.loop(); // 启动事件循环，等待 quit()
  t.join();
  ::close(fd[0]); ::close(fd[1]);
}
```

> ✅ **关键点**：
> - 用 `socketpair` 模拟网络 I/O；
> - 回调中调用 `loop.quit()` 终止循环；
> - 测试在主线程完成，无需真实网络。

---

### 2. `createSocketPair()` 的作用与为何不用真实网络？

#### ▶ `createSocketPair()` 做什么？
```cpp
// test_tcpconnection.cpp
std::pair<int, int> createSocketPair() {
  int fd[2];
  ::socketpair(AF_UNIX, SOCK_STREAM, 0, fd);
  return {fd[0], fd[1]};
}
```
- 创建一对**已连接的 Unix domain socket**（`fd[0]` 和 `fd[1]` 互为对端）；
- 数据写入 `fd[0]` 可从 `fd[1]` 读出，反之亦然。

#### ▶ 为什么不用真实网络（如 localhost:12345）？
| 问题 | 真实网络 | `socketpair` |
|------|--------|-------------|
| **速度** | 慢（涉及 TCP/IP 协议栈） | 极快（内核内存拷贝） |
| **可靠性** | 可能被防火墙/端口占用干扰 | 完全可控，无外部依赖 |
| **隔离性** | 多个测试可能冲突 | 每个测试独占 fd 对 |
| **可预测性** | 受网络延迟影响 | 行为确定，适合自动化 |

> ✅ **工程原则**：单元测试应**快速、可靠、可重复**，`socketpair` 是测试网络库的理想 mock。

---

## 二、调试与实战经验

### 1. 最具挑战性的 Bug：对象生命周期与跨线程析构

#### ▶ Bug 现象：
- 程序偶尔 crash，backtrace 显示在 `TcpConnection::handleRead()` 中访问了非法内存；
- Valgrind 报告 “invalid read of size 8”。

#### ▶ 根本原因：
- **回调执行期间对象被销毁**：
  ```cpp
  // 用户代码
  void onMessage(const TcpConnectionPtr& conn, ...) {
    if (bad_condition) {
      conn->forceClose(); // → 触发 ~TcpConnection()
    }
    conn->send("reply"); // ← 此时 conn 已析构！
  }
  ```
- 虽然用了 `shared_ptr`，但 `forceClose()` 导致引用计数归零，对象立即析构。

#### ▶ 解决方案：
- **禁止在回调中直接关闭连接**，改为：
  ```cpp
  void onMessage(const TcpConnectionPtr& conn, ...) {
    if (bad_condition) {
      conn->getLoop()->runInLoop(
        std::bind(&TcpConnection::forceClose, conn));
      return; // 不再操作 conn
    }
    conn->send("reply");
  }
  ```
- 或者，**确保 `conn` 在回调结束前不被释放**（通过延长 `shared_ptr` 生命周期）。

> 🔍 **经验总结**：  
> - **“回调中不要释放自己”** 是网络编程铁律；  
> - 使用 `shared_from_this()` 并确保回调持有 `shared_ptr`；  
> - 关键操作（如 close）应提交到 `EventLoop` 异步执行。

---

### 2. 内存泄漏验证方法与工具

#### ▶ 静态检查：
- **编译器警告**：开启 `-Wall -Wextra`，检查未使用变量、资源未释放；
- **RAII 审查**：确保所有 `fd`、`pthread_t` 等由 RAII 对象（如 `Socket`、`Thread`）管理。

#### ▶ 动态检测工具：
| 工具 | 用途 | 使用方式 |
|------|------|--------|
| **Valgrind (memcheck)** | 检测内存泄漏、非法访问 | `valgrind --leak-check=full ./test_tcpconnection` |
| **gperftools (tcmalloc)** | 实时内存分析、堆栈追踪 | 链接 `-ltcmalloc`，运行后生成 profile |
| **AddressSanitizer (ASan)** | 快速检测 use-after-free、heap-buffer-overflow | 编译加 `-fsanitize=address` |

#### ▶ 典型测试流程：
1. 编写压力测试（如创建/销毁 10,000 个连接）；
2. 用 Valgrind 运行：
   ```bash
   valgrind --leak-check=full --show-leak-kinds=all \
            --track-origins=yes ./tests/test_tcpconnection
   ```
3. 验证输出中无 “definitely lost” 或 “possibly lost” 块。

> ✅ **关键发现**：  
> - 早期版本中，`EventLoop` 的 `pendingFunctors_` 若捕获 `this` 可能导致循环引用；  
> - 通过改用 `weak_ptr` 或确保任务不持有长期引用解决。

---

## 总结回答（面试口语化精简版）

> “我们为 `EventLoop` 编写单元测试时，通过 `EventLoopThread` 控制事件循环，并用 `socketpair` 模拟 I/O 事件，避免依赖真实网络。`createSocketPair()` 创建一对已连接的 Unix socket，让测试快速、可靠、无外部依赖。
>
> 我遇到的最棘手 bug 是回调中对象被提前析构——用户在 `onMessage` 里直接 `forceClose()`，导致后续 `send()` 访问悬空指针。解决方案是将关闭操作提交到 `EventLoop` 异步执行，确保回调安全。
>
> 为验证无内存泄漏，我们用 Valgrind 和 AddressSanitizer 运行全套单元测试，特别关注连接频繁创建/销毁的场景。所有资源（如 fd、线程）都通过 RAII 管理，确保异常安全。”

