è¿™æ˜¯ä¸€ä¸ªè€ƒå¯Ÿ **C++ æ¨¡æ¿åŸºç¡€ç†è§£ä¸æ³›å‹è®¾è®¡èƒ½åŠ›** çš„é—®é¢˜ï¼Œæ—¢æ¶‰åŠæ ‡å‡†åº“å®¹å™¨çš„åº•å±‚æœºåˆ¶ï¼Œä¹Ÿæ¶‰åŠå¦‚ä½•ç”¨æ¨¡æ¿æå‡ä»£ç å¤ç”¨æ€§ã€‚ä¸‹é¢æˆ‘å°†ç»“åˆ **re_muduo** é¡¹ç›®ç»“æ„ï¼Œä»å®¹å™¨åŸç†åˆ°æ³›å‹ `Buffer` è®¾è®¡è¿›è¡Œç³»ç»Ÿæ€§å›ç­”ã€‚

---

### 1. æ ‡å‡†åº“å®¹å™¨ï¼ˆå¦‚ `std::vector<Channel*>`, `std::unordered_map<int, TcpConnectionPtr>`ï¼‰çš„å·¥ä½œåŸç†

#### âœ… æ ¸å¿ƒæœºåˆ¶ï¼š**ç¼–è¯‘æ—¶å¤šæ€ + ç±»å‹å®‰å…¨**

- **æ¨¡æ¿å®ä¾‹åŒ–**ï¼š
  ```cpp
  std::vector<Channel*> channels_;
  std::unordered_map<int, TcpConnectionPtr> connectionMap_;
  ```
  ç¼–è¯‘å™¨ä¼šä¸ºæ¯ç§ç±»å‹ç»„åˆç”Ÿæˆ**ç‹¬ç«‹çš„ä»£ç **ï¼š
  - `vector<Channel*>` â†’ ä¸“ç”¨äºå­˜å‚¨ `Channel*` çš„åŠ¨æ€æ•°ç»„
  - `unordered_map<int, TcpConnectionPtr>` â†’ å“ˆå¸Œè¡¨ï¼Œkey ä¸º `int`ï¼Œvalue ä¸º `shared_ptr<TcpConnection>`

- **å†…å­˜å¸ƒå±€ä¸æ“ä½œ**ï¼š
  | å®¹å™¨                | å†…å­˜æ¨¡å‹                          | å…³é”®æ“ä½œå¤æ‚åº¦       |
  |---------------------|-----------------------------------|----------------------|
  | `std::vector<T>`    | è¿ç»­å†…å­˜å—ï¼Œæ”¯æŒéšæœºè®¿é—®          | `push_back`: O(1) amortized |
  | `std::unordered_map<K,V>` | å“ˆå¸Œæ¡¶ + é“¾è¡¨/çº¢é»‘æ ‘ï¼ˆå†²çªè§£å†³ï¼‰ | `insert/find`: O(1) average |

- **åœ¨ muduo ä¸­çš„ä½œç”¨**ï¼š
  - `vector<Channel*>`ï¼š`Poller` ç”¨äºè¿”å›æ´»è·ƒäº‹ä»¶é€šé“åˆ—è¡¨ï¼ˆ`poll()` è¾“å‡ºå‚æ•°ï¼‰
  - `unordered_map<int, TcpConnectionPtr>`ï¼š`TcpServer` ç®¡ç†æ‰€æœ‰è¿æ¥ï¼Œé€šè¿‡ fd æˆ– name å¿«é€ŸæŸ¥æ‰¾

> ğŸ’¡ **ä¸ºä»€ä¹ˆç”¨æŒ‡é’ˆ/æ™ºèƒ½æŒ‡é’ˆï¼Ÿ**
> - `Channel*`ï¼šé¿å…å¯¹è±¡æ‹·è´ï¼ˆ`Channel` ä¸å¯å¤åˆ¶ï¼‰ï¼Œä¸” `Poller` åªéœ€è§‚å¯Ÿ
> - `TcpConnectionPtr`ï¼ˆ`shared_ptr`ï¼‰ï¼šæ”¯æŒå¤šå¤„å…±äº«è¿æ¥å¯¹è±¡ï¼Œè‡ªåŠ¨ç®¡ç†ç”Ÿå‘½å‘¨æœŸ

---

### 2. æ³›å‹åŒ– `Buffer` çš„æ•´æ•°è¯»å†™ï¼šæ¨¡æ¿æˆå‘˜å‡½æ•°è®¾è®¡

#### âœ… ç›®æ ‡ï¼šé¿å…ä¸º `int16_t`ã€`int32_t`ã€`int64_t` é‡å¤ç¼–å†™ `retrieveIntXX` / `appendIntXX`

#### ğŸ”§ æ–¹æ¡ˆï¼šä½¿ç”¨ **æ¨¡æ¿æˆå‘˜å‡½æ•°**

```cpp
// Buffer.h
class Buffer : noncopyable {
public:
    // é€šç”¨è¯»å–
    template<typename T>
    T readInt();

    // é€šç”¨è¿½åŠ 
    template<typename T>
    void appendInt(T value);

private:
    static_assert(std::is_integral_v<T>, "T must be integral type");
};
```

#### ğŸ›  å®ç°ç¤ºä¾‹ï¼ˆéœ€å¤„ç†å­—èŠ‚åºï¼‰ï¼š

```cpp
// Buffer.cpp
template<typename T>
T Buffer::readInt() {
    assert(readableBytes() >= sizeof(T));
    T result = 0;
    memcpy(&result, peek(), sizeof(T));  // é¿å…æœªå¯¹é½è®¿é—®
    retrieve(sizeof(T));

    // è½¬æ¢ç½‘ç»œå­—èŠ‚åºï¼ˆå¤§ç«¯ï¼‰ â†’ ä¸»æœºå­—èŠ‚åº
    if constexpr (sizeof(T) == 2) {
        return ntohs(result);
    } else if constexpr (sizeof(T) == 4) {
        return ntohl(result);
    } else if constexpr (sizeof(T) == 8) {
        // æ³¨æ„ï¼šntohll ä¸æ˜¯æ ‡å‡† C å‡½æ•°ï¼Œéœ€è‡ªå®šä¹‰æˆ–ä½¿ç”¨ __builtin_bswap64
        return bswap_64(result);  // å‡è®¾æœ‰ bswap_64
    }
    return result;
}

template<typename T>
void Buffer::appendInt(T value) {
    // è½¬æ¢ä¸»æœºå­—èŠ‚åº â†’ ç½‘ç»œå­—èŠ‚åºï¼ˆå¤§ç«¯ï¼‰
    T netValue;
    if constexpr (sizeof(T) == 2) {
        netValue = htons(value);
    } else if constexpr (sizeof(T) == 4) {
        netValue = htonl(value);
    } else if constexpr (sizeof(T) == 8) {
        netValue = bswap_64(value);
    }

    append(static_cast<const char*>(static_cast<const void*>(&netValue)), sizeof(T));
}
```

> âš ï¸ **å…³é”®æ³¨æ„äº‹é¡¹**ï¼š

#### 1. **å­—èŠ‚åºï¼ˆEndiannessï¼‰é—®é¢˜**
- **ç½‘ç»œåè®®è§„å®š**ï¼šæ•´æ•°åœ¨ç½‘ç»œä¸Šä¼ è¾“å¿…é¡»æ˜¯ **å¤§ç«¯ï¼ˆBig-Endianï¼‰**ã€‚
- **ä¸»æœºå­—èŠ‚åº**ï¼šx86/x64 æ˜¯å°ç«¯ï¼ˆLittle-Endianï¼‰ï¼ŒARM å¯é…ç½®ã€‚
- **å¿…é¡»è½¬æ¢**ï¼šä½¿ç”¨ `htonl`/`ntohl`ï¼ˆ32ä½ï¼‰ã€`htons`/`ntohs`ï¼ˆ16ä½ï¼‰ï¼Œ64ä½éœ€è‡ªå®šä¹‰ï¼ˆå¦‚ `bswap_64`ï¼‰ã€‚

#### 2. **å¯¹é½ï¼ˆAlignmentï¼‰é—®é¢˜**
- ç›´æ¥ `*(T*)peek()` å¯èƒ½å¯¼è‡´ **æœªå¯¹é½è®¿é—®**ï¼ˆå°¤å…¶åœ¨ ARM ä¸Šå´©æºƒï¼‰ã€‚
- **å®‰å…¨åšæ³•**ï¼šä½¿ç”¨ `memcpy`ï¼ˆç°ä»£ç¼–è¯‘å™¨ä¼šä¼˜åŒ–ä¸ºå•æ¡æŒ‡ä»¤ï¼‰ã€‚

#### 3. **æ¨¡æ¿å®ä¾‹åŒ–æ§åˆ¶**
- åœ¨ `.cpp` ä¸­å®šä¹‰æ¨¡æ¿ä¼šå¯¼è‡´é“¾æ¥é”™è¯¯ï¼ˆé™¤éæ˜¾å¼å®ä¾‹åŒ–ï¼‰ã€‚
- **æ¨èåšæ³•**ï¼šå°†æ¨¡æ¿å®šä¹‰æ”¾åœ¨ `.h` æ–‡ä»¶ä¸­ï¼ˆæˆ–ä½¿ç”¨ `inline`ï¼‰ã€‚

#### 4. **ç±»å‹å®‰å…¨çº¦æŸ**
- ä½¿ç”¨ `static_assert` é™åˆ¶åªæ”¯æŒæ•´æ•°ç±»å‹ï¼š
  ```cpp
  template<typename T>
  void appendInt(T value) {
      static_assert(std::is_integral_v<T>, "Only integral types allowed");
      // ...
  }
  ```

---

### å¯¹æ¯”ï¼šé‡è½½ vs æ¨¡æ¿

| æ–¹æ¡ˆ       | ä¼˜ç‚¹                          | ç¼ºç‚¹                          |
|------------|-------------------------------|-------------------------------|
| é‡è½½       | æ˜¾å¼æ§åˆ¶æ¯ä¸ªç±»å‹è¡Œä¸º          | ä»£ç é‡å¤ï¼Œæ‰©å±•æ–°ç±»å‹éœ€æ”¹å¤šå¤„  |
| æ¨¡æ¿       | ä¸€æ¬¡ç¼–å†™ï¼Œæ”¯æŒæ‰€æœ‰æ•´æ•°ç±»å‹    | éœ€å¤„ç†å­—èŠ‚åº/å¯¹é½ç­‰é€šç”¨é€»è¾‘   |

> ğŸ’¡ **muduo çš„å®é™…é€‰æ‹©**ï¼š  
> åŸå§‹ muduo ä½¿ç”¨é‡è½½ï¼ˆ`retrieveInt32` ç­‰ï¼‰ï¼Œå› ä¸ºï¼š
> - ç±»å‹æœ‰é™ï¼ˆé€šå¸¸åªéœ€ 16/32/64 ä½ï¼‰
> - é¿å…æ¨¡æ¿å¸¦æ¥çš„ç¼–è¯‘æ—¶é—´å¢åŠ 
> - æ˜ç¡®æ§åˆ¶å­—èŠ‚åºè½¬æ¢  
> ä½†åœ¨ç°ä»£ C++ é¡¹ç›®ä¸­ï¼Œ**æ¨¡æ¿æ–¹æ¡ˆæ›´ç¬¦åˆ DRY åŸåˆ™**ï¼Œå°¤å…¶å½“åè®®æ”¯æŒå¤šç§æ•´æ•°ç±»å‹æ—¶ã€‚

---

### æ€»ç»“

| é—®é¢˜ç‚¹                         | å…³é”®ç»“è®º                                                                 |
|--------------------------------|--------------------------------------------------------------------------|
| æ ‡å‡†åº“å®¹å™¨å·¥ä½œåŸç†             | æ¨¡æ¿å®ä¾‹åŒ–ç”Ÿæˆç±»å‹ä¸“ç”¨ä»£ç ï¼Œæä¾›é«˜æ•ˆã€ç±»å‹å®‰å…¨çš„å†…å­˜ç®¡ç†                 |
| æ³›å‹ `Buffer` æ•´æ•°è¯»å†™         | ä½¿ç”¨æ¨¡æ¿æˆå‘˜å‡½æ•° + `constexpr if` å¤„ç†ä¸åŒå¤§å°ç±»å‹ï¼Œ**å¿…é¡»å¤„ç†å­—èŠ‚åºå’Œå¯¹é½** |

å¦‚æœæ‚¨å¸Œæœ›æˆ‘ç»“åˆ `re_muduo` ä¸­ `Buffer.h/cpp` çš„ç°æœ‰ `retrieveInt32` å®ç°ï¼Œç»™å‡ºå®Œæ•´çš„æ¨¡æ¿åŒ–é‡æ„ä»£ç ï¼Œè¯·æä¾›ç›¸å…³ç‰‡æ®µï¼Œæˆ‘å¯ä»¥åšé€è¡Œæ›¿æ¢å»ºè®®ã€‚