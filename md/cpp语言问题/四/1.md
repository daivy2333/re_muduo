
---

### 1. `Thread` ç±»å¦‚ä½•å…³è”æ‰§è¡Œå‡½æ•°ä¸ `std::thread`

#### âœ… æ ¸å¿ƒæœºåˆ¶ï¼š**é€šè¿‡ lambda æ•è·æˆå‘˜å˜é‡å¯åŠ¨çº¿ç¨‹**

åœ¨ `re_muduo` çš„ `Thread.cpp` ä¸­ï¼Œå…¸å‹å®ç°å¦‚ä¸‹ï¼š

```cpp
// Thread.h
class Thread : noncopyable {
public:
    using ThreadFunc = std::function<void()>;
    explicit Thread(ThreadFunc func, const std::string& name = std::string());

private:
    void start(); // å¯åŠ¨çº¿ç¨‹
    static void* threadFunc(void* arg); // çº¿ç¨‹å…¥å£ï¼ˆPOSIX é£æ ¼ï¼‰
    
    ThreadFunc func_;      // ç”¨æˆ·æä¾›çš„æ‰§è¡Œå‡½æ•°
    std::thread thread_;   // C++11 std::thread å¯¹è±¡
    bool started_;
};
```

```cpp
// Thread.cpp
void Thread::start() {
    assert(!started_);
    started_ = true;
    
    // å…³é”®ï¼šé€šè¿‡ lambda æ•è· thisï¼Œè°ƒç”¨ func_
    thread_ = std::thread([this]() {
        // è®¾ç½®çº¿ç¨‹åã€ç¼“å­˜ tid ç­‰
        CurrentThread::cacheTid();
        if (!name_.empty()) {
            // ... è®¾ç½®çº¿ç¨‹å
        }
        try {
            func_(); // æ‰§è¡Œç”¨æˆ·é€»è¾‘
        } catch (...) {
            // å¼‚å¸¸å¤„ç†
        }
    });
}
```

#### ğŸ” å…³é”®è®¾è®¡è¦ç‚¹ï¼š

- **å¯åŠ¨æ—¶æœº**ï¼š  
  `std::thread` å¯¹è±¡åœ¨æ„é€ æ—¶**ç«‹å³å¯åŠ¨çº¿ç¨‹**ã€‚å› æ­¤å¿…é¡»ç¡®ä¿ï¼š
  - `func_` å·²æ­£ç¡®åˆå§‹åŒ–ï¼ˆåœ¨ `start()` å‰èµ‹å€¼ï¼‰
  - `this` å¯¹è±¡å·²å®Œå…¨æ„é€ ï¼ˆé¿å…åœ¨æ„é€ å‡½æ•°ä¸­å¯åŠ¨çº¿ç¨‹ï¼‰

- **lambda æ•è· `this`**ï¼š  
  é€šè¿‡ `[this]` æ•è·ï¼Œä½¿æ–°çº¿ç¨‹èƒ½è®¿é—® `Thread` å¯¹è±¡çš„æˆå‘˜ï¼ˆå¦‚ `func_`, `name_`ï¼‰ã€‚

- **å¼‚å¸¸å®‰å…¨**ï¼š  
  åŒ…è£¹ `func_()` åœ¨ `try-catch` ä¸­ï¼Œé˜²æ­¢çº¿ç¨‹å› æœªå¤„ç†å¼‚å¸¸è€Œç»ˆæ­¢ã€‚

> ğŸ’¡ **ä¸ºä»€ä¹ˆä¸ç”¨ `std::bind`ï¼Ÿ**  
> Lambda æ›´ç®€æ´ã€é«˜æ•ˆï¼Œä¸”èƒ½ç›´æ¥æ•è·å±€éƒ¨çŠ¶æ€ï¼Œæ˜¯ç°ä»£ C++ çš„é¦–é€‰ã€‚

---

### 2. `EventLoop::queueInLoop` ä¸­äº’æ–¥é”çš„ä½œç”¨ä¸ç²’åº¦

#### âœ… ä¸ºä»€ä¹ˆéœ€è¦ `mutex_`ï¼Ÿ

```cpp
// EventLoop.h
class EventLoop : noncopyable {
private:
    mutable std::mutex mutex_;
    std::vector<Functor> pendingFunctors_; // å¾…æ‰§è¡Œçš„å¼‚æ­¥ä»»åŠ¡
};
```

```cpp
// EventLoop.cpp
void EventLoop::queueInLoop(Functor cb) {
    {
        std::lock_guard<std::mutex> lock(mutex_);
        pendingFunctors_.push_back(std::move(cb));
    }
    if (!isInLoopThread() || callingPendingFunctors_) {
        wakeup(); // å”¤é†’ EventLoop çº¿ç¨‹
    }
}
```

#### ğŸ” é”çš„å¿…è¦æ€§ï¼š

- **å¤šç”Ÿäº§è€…åœºæ™¯**ï¼š  
  ä»»æ„çº¿ç¨‹ï¼ˆåŒ…æ‹¬é `EventLoop` çº¿ç¨‹ï¼‰éƒ½å¯è°ƒç”¨ `queueInLoop`ï¼Œå‘ `pendingFunctors_` æ·»åŠ ä»»åŠ¡ã€‚
- **æ•°æ®ç«äº‰é£é™©**ï¼š  
  è‹¥æ— é”ä¿æŠ¤ï¼Œå¤šä¸ªçº¿ç¨‹åŒæ—¶ `push_back` ä¼šå¯¼è‡´ `vector` å†…éƒ¨çŠ¶æ€æŸåï¼ˆå¦‚ size/capacity ä¸ä¸€è‡´ï¼‰ã€‚

#### ğŸ“ é”çš„ç²’åº¦ï¼š

- **ç»†ç²’åº¦**ï¼šä»…ä¿æŠ¤ `pendingFunctors_` çš„ä¿®æ”¹æ“ä½œï¼ˆ`push_back`ï¼‰ã€‚
- **ä¸´ç•ŒåŒºæå°**ï¼š  
  é”åªåœ¨ `push_back` æœŸé—´æŒæœ‰ï¼Œä¸åŒ…å« `wakeup()`ï¼ˆé¿å…é˜»å¡ I/O çº¿ç¨‹ï¼‰ã€‚
- **æ€§èƒ½å½±å“ä½**ï¼š  
  `pendingFunctors_` é€šå¸¸ä»»åŠ¡è¾ƒå°‘ï¼Œä¸” `vector::push_back` æ˜¯ O(1) amortizedã€‚

> ğŸ’¡ **ä¸ºä»€ä¹ˆ `mutex_` æ˜¯ `mutable`ï¼Ÿ**  
> å› ä¸º `queueInLoop` å¯èƒ½åœ¨ `const EventLoop*` ä¸Šè°ƒç”¨ï¼ˆè™½ç„¶ muduo ä¸­é€šå¸¸é constï¼‰ï¼Œä½†æ›´ä¸»è¦çš„æ˜¯éµå¾ªâ€œé€»è¾‘ constâ€åŸåˆ™â€”â€”åŠ é”ä¸å½±å“å¯¹è±¡é€»è¾‘çŠ¶æ€ã€‚

---

### 3. å…¨å±€åŸå­è®¡æ•°å™¨ç»Ÿè®¡ `TcpConnection` æ€»æ•°

#### âœ… æ­£ç¡®ç±»å‹ï¼š`std::atomic<int>`

```cpp
// TcpConnection.h
class TcpConnection : noncopyable {
public:
    TcpConnection(...);
    ~TcpConnection();
private:
    static std::atomic<int> connectionCount_;
};

// TcpConnection.cpp
std::atomic<int> TcpConnection::connectionCount_{0};

TcpConnection::TcpConnection(...) {
    ++connectionCount_; // åŸå­è‡ªå¢
}

TcpConnection::~TcpConnection() {
    --connectionCount_; // åŸå­è‡ªå‡
}
```

#### ğŸ” ä¸ºä»€ä¹ˆå¿…é¡»ç”¨ `std::atomic`ï¼Ÿ

| æ–¹æ¡ˆ                | é—®é¢˜                                                                 |
|---------------------|----------------------------------------------------------------------|
| `int connectionCount_` | å¤šçº¿ç¨‹åŒæ—¶ `++` ä¼šå¯¼è‡´**æ•°æ®ç«äº‰ï¼ˆdata raceï¼‰** â†’ æœªå®šä¹‰è¡Œä¸º          |
| `std::mutex` ä¿æŠ¤    | è¿‡é‡ï¼æ¯æ¬¡æ„é€ /ææ„éƒ½è¦åŠ é”ï¼Œä¸¥é‡å½±å“æ€§èƒ½ï¼ˆè¿æ¥åˆ›å»º/é”€æ¯æ˜¯é«˜é¢‘æ“ä½œï¼‰ |
| `__thread` / `thread_local` | æ¯ä¸ªçº¿ç¨‹ç‹¬ç«‹è®¡æ•°ï¼Œæ— æ³•å¾—åˆ°**å…¨å±€æ€»æ•°**                              |

#### ğŸ’¡ `std::atomic` çš„ä¼˜åŠ¿ï¼š

- **æ— é”æ“ä½œ**ï¼šåœ¨ x86 ä¸Šï¼Œ`++atomic_int` ç¼–è¯‘ä¸ºå•æ¡ `lock inc` æŒ‡ä»¤ã€‚
- **å†…å­˜åºä¿è¯**ï¼šé»˜è®¤ä½¿ç”¨ `memory_order_seq_cst`ï¼Œä¿è¯æ‰€æœ‰çº¿ç¨‹çœ‹åˆ°ä¸€è‡´çš„è®¡æ•°å€¼ã€‚
- **æ€§èƒ½æé«˜**ï¼šæ¯”äº’æ–¥é”å¿« 10-100 å€ï¼ˆå°¤å…¶åœ¨ä½ç«äº‰åœºæ™¯ï¼‰ã€‚

> ğŸ“Œ **æ³¨æ„**ï¼šè‹¥éœ€æ›´é«˜æ€§èƒ½ï¼ˆå¦‚æ¯ç§’ç™¾ä¸‡çº§è¿æ¥ï¼‰ï¼Œå¯è€ƒè™‘ **per-thread counter + å®šæœŸèšåˆ**ï¼Œä½†å¯¹å¤§å¤šæ•°åœºæ™¯ `std::atomic<int>` è¶³å¤Ÿã€‚

---

### æ€»ç»“è¡¨

| é—®é¢˜ç‚¹                         | å…³é”®ç»“è®º                                                                 |
|--------------------------------|--------------------------------------------------------------------------|
| `Thread` å¯åŠ¨æœºåˆ¶              | é€šè¿‡ lambda æ•è· `this`ï¼Œåœ¨ `std::thread` æ„é€ æ—¶ç«‹å³å¯åŠ¨                  |
| `queueInLoop` äº’æ–¥é”           | ä¿æŠ¤å¤šçº¿ç¨‹å†™å…¥ `pendingFunctors_`ï¼Œé”ç²’åº¦æå°ï¼ˆä»… `push_back`ï¼‰           |
| å…¨å±€è¿æ¥è®¡æ•°å™¨                 | `std::atomic<int>`ï¼šæ— é”ã€åŸå­ã€é«˜æ€§èƒ½ï¼Œé¿å…æ•°æ®ç«äº‰                      |

---

