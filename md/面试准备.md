清单涵盖了技术理解、设计思路、实现细节等多个维度，可以帮助你全面评估候选人的能力。

一、 项目结构与设计理念 (宏观理解)

这些问题旨在考察实习生对项目整体架构的理解，以及他/她为何这样组织代码。

1.  模块划分：
    ◦   这个 muduo 复现项目主要包含了哪些核心模块？（例如：EventLoop, Channel, Poller, TcpConnection, Buffer 等）。你能简要说明每个模块的职责吗？

    ◦   为什么将 Socket、InetAddress、Channel、Poller 等设计成独立的类？这样的设计有什么好处？

    ◦   noncopyable.h 头文件的作用是什么？你在哪些类中继承了它，为什么？

2.  核心模型：
    ◦   请解释一下 Reactor 模式。在这个项目中，哪些部分对应了 Reactor 模式中的 Demultiplexer、Dispatcher 和 EventHandler？

    ◦   项目采用的是 one loop per thread 的线程模型吗？如果是，EventLoopThread 和 EventLoopThreadPool 是如何协作来实现这一模型的？

3.  依赖管理：
    ◦   我注意到有 Poller.h 和 EpollPoller.h/cpp，还有 DefaultPoller.cpp。这是如何实现多路复用器（如 epoll, poll）的可插拔设计的？DefaultPoller.cpp 具体做了什么？

二、 核心组件实现细节 (深入考察)

这部分聚焦于关键类的实现，考察编码功底和对系统编程的理解。

1. EventLoop 事件循环 (u18, u27)

•   核心机制：

    ◦   EventLoop::loop() 函数的核心逻辑是什么？它是如何等待和分发事件的？

    ◦   EventLoop 中 wakeupFd_（由 createEventfd 创建）的作用是什么？在什么场景下会用到它？（提示：runInLoop 与 queueInLoop）

    ◦   pendingFunctors_ 这个队列是做什么用的？为什么需要一把锁（mutex_）来保护它？这解决了什么问题？

•   线程安全性：

    ◦   如何保证一个 EventLoop 对象只被其所属的线程调用？assertInLoopThread() 是怎么实现的？

    ◦   runInLoop(const Functor& cb) 这个函数如何实现“在当前IO线程执行回调”？如果调用线程不是IO线程，它会怎么做？

2. Channel 与 Poller (u15, u20, u22, u25, u33)

•   关系与职责：

    ◦   Channel、Poller 和 EventLoop 三者之间的关系是怎样的？请描述从事件注册到回调执行的完整流程。

    ◦   Channel 类中 events_ 和 revents_ 成员变量分别代表什么？是谁来设置它们的值？

    ◦   Channel::handleEvent() 被谁调用？它内部是如何根据 revents_ 来分发到不同的回调函数（如 readCallback_, writeCallback_）的？

•   EpollPoller 实现：

    ◦   在 EpollPoller::updateChannel(Channel* channel) 中，你是如何区分添加（EPOLL_CTL_ADD）和修改（EPOLL_CTL_MOD）操作的？

    ◦   EpollPoller::fillActiveChannels 函数的目的是什么？为什么需要这个步骤？

3. TcpConnection 连接管理 (u5, u34)

•   生命周期：

    ◦   一个 TcpConnection 对象从建立到销毁会经历哪几个状态（kConnecting, kConnected, kDisconnecting, kDisconnected）？状态变迁是如何触发的？

    ◦   TcpConnection 的析构函数需要做什么？为什么说 Channel 的生命周期由 TcpConnection 管理？

•   数据读写：

    ◦   TcpConnection 使用了 Buffer 类作为输入和输出缓冲区。请描述当可读事件发生时，数据是如何从 socket 读到 inputBuffer_，再通过 messageCallback_ 交给用户的。

    ◦   当用户调用 TcpConnection::send() 发送数据时，如果当前输出缓冲区已有数据（即一次没发完），这些数据是如何被缓存并等待下次可写事件的？highWaterMarkCallback_ 在这里起什么作用？

    ◦   如何实现“连接关闭”功能？shutdown 和 close 系统调用在 TcpConnection::shutdown 和析构函数中是如何使用的？

4. Buffer 设计 (u14, u31)

•   内存管理：

    ◦   你的 Buffer 内部是如何组织内存的？（提示：readerIndex_, writerIndex_, prependable 空间）。这种设计相比简单的 vector<char> 有什么优势？

    ◦   append 操作时，如果剩余空间不足，makeSpace 函数会怎么做？是每次都重新分配吗？shrink 函数在什么情况下会被调用？

    ◦   retrieve 系列函数做了什么？它们真的释放了内存吗？为什么？

•   应用协议处理：

    ◦   假设要基于这个 Buffer 实现一个简单的行协议（以 \r\n 结尾），如何使用 findCRLF() 和 retrieveUntil 等函数来读取一行数据？

5. Acceptor 与 TcpServer (u2, u19, u10, u16)

•   连接建立：

    ◦   Acceptor 的主要职责是什么？它内部有自己的 Channel 吗？监听的是哪个 socket？

    ◦   当新连接到达时，Acceptor::handleRead() 会做什么？它如何创建新的 TcpConnection 对象？

•   多线程服务：

    ◦   TcpServer 是如何使用 EventLoopThreadPool 来支持多线程处理连接的？getNextLoop() 方法是如何选择 EventLoop 的？（如轮询）

    ◦   connectionCallback_ 和 messageCallback_ 等用户回调是在哪个线程中被调用的？如何保证线程安全？

三、 C++ 与系统编程特性

•   智能指针与对象生命周期：

    ◦   项目中大量使用了 std::unique_ptr 和 std::shared_ptr。请举例说明你在哪里用了 shared_ptr 来管理 TcpConnection 的生命周期，为什么必须这么做？（提示：跨线程、回调执行时对象可能被销毁）

    ◦   在 Channel 中，你保存了其所属 EventLoop 的原始指针。为什么这里不用智能指针？

•   回调机制：

    ◦   项目中使用了 std::function 来定义回调（见 Callbacks.h）。这种设计与传统的虚函数接口相比有什么优缺点？

    ◦   你是如何绑定成员函数作为回调的？（例如，TcpServer 给 Acceptor 设置 newConnectionCallback_ 时）

•   系统调用与错误处理：

    ◦   在 Socket.cpp 中，设置 SO_REUSEADDR 等选项的目的是什么？

    ◦   在网络编程中，EAGAIN（或 EWOULDBLOCK）错误是常见的。在你的代码中，哪些系统调用需要处理这种错误？你是怎么处理的？

    ◦   createNonblockingOrDie 这个函数名中的“OrDie”是什么意思？你的项目中是如何实现“OrDie”的？（是终止程序还是有其他错误传播机制？）

四、 测试与调试 (关注工程能力)

•   单元测试：

    ◦   我看到有一个庞大的 tests/ 目录。你是如何为像 EventLoop 这样事件驱动的组件编写单元测试的？

    ◦   在 test_tcpconnection.cpp 中，createSocketPair() 函数是做什么用的？为什么测试网络连接不直接使用真实的网络？

•   调试与经验：

    ◦   在实现这个网络库的过程中，你遇到的最具挑战性的 bug 是什么？你是如何定位和解决它的？（可以考察其对多线程竞争、对象生命周期、资源泄漏等问题的理解）

    ◦   你如何验证你的网络库没有内存泄漏？使用过什么工具（如 Valgrind, gperftools）吗？

五、 开放性问题 (考察潜力与思考)

1.  性能考量：你觉得当前实现的性能瓶颈可能在哪里？如果让你进一步优化，你会从哪些方面入手？（例如：零拷贝、缓冲区设计、锁粒度、定时器效率）
2.  功能扩展：如果需要你为这个库添加一个简单的定时器（Timer）功能，以支持超时断开连接或心跳，你会如何设计？将这个功能集成到现有的 EventLoop 中。
3.  对比与思考：你的实现与原始的 muduo 库（或你所参考的其他版本）主要的区别在哪里？你做这些改动的理由是什么？
