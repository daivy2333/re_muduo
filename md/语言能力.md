好的，基于这个 muduo 网络库复现项目，我为你设计了一份针对 C++ 语言能力的深度面试问题清单。这份清单将聚焦于项目中实际使用的 C++ 特性，通过具体代码场景来考察实习生的理解和应用能力。

C++ 语言能力面试问题清单

一、 现代 C++ 特性与应用（核心考察点）

1. 智能指针与内存管理
•   std::unique_ptr 与 std::shared_ptr 的选用：

    ◦   在 EventLoop 中，poller_ 成员是 std::unique_ptr<Poller>。为什么这里用 unique_ptr 而不用 shared_ptr？

    ◦   在 TcpConnection 中，你看到 TcpConnectionPtr 被定义为 std::shared_ptr<TcpConnection>。为什么连接对象需要用 shared_ptr 管理？能具体描述一个场景，说明如果这里用 unique_ptr 或原始指针会导致什么问题吗？（提示：跨线程回调、connectionMap_ 持有引用）

    ◦   Channel 类中有一个 EventLoop* loop_ 成员，这里为什么用原始指针而不是智能指针？这样设计是否存在循环引用的风险？为什么？

2. std::function、std::bind 与回调机制
•   类型擦除与灵活性：

    ◦   Callbacks.h 中定义了大量的 std::function 类型（如 ConnectionCallback、MessageCallback）。相比使用抽象基类和虚函数，这种设计有什么优点？（提示：类型擦除、可绑定任意可调用对象、包括lambda）。

    ◦   请写一段示例代码，展示如何将一个类的非静态成员函数（如 TcpServer::newConnection）通过 std::bind 绑定为一个 std::function，并设置给 Acceptor 作为 newConnectionCallback_。std::placeholders::_1 在这里代表什么？

    ◦   Lambda 表达式在这个项目中有潜在的应用场景吗？比如在 EventLoop::runInLoop 中传入一个 Lambda，它如何捕获局部变量？这会带来什么需要注意的问题？（提示：生命周期、按值捕获与按引用捕获）。

3. 移动语义与右值引用
•   性能优化：

    ◦   查看 Buffer::append(const char* data, size_t len) 和 Buffer::append(const string& str)。如果我想增加一个高效添加字符串的接口，支持移动一个已有的 std::string 到 Buffer 中，应该如何声明这个函数？（答案：void append(std::string&& str)）。

    ◦   在 Buffer 的 retrieveAllAsString() 实现中，如果返回类型是 std::string，如何利用移动语义来避免一次不必要的拷贝？

    ◦   Socket 类禁用了拷贝（继承 noncopyable），但它可能有移动构造函数和移动赋值运算符吗？为什么需要或不需要？

4. const 正确性与成员函数设计
•   接口设计：

    ◦   找出项目中几个标记为 const 的成员函数（例如 EventLoop::isInLoopThread()）。为什么它们需要是 const 的？

    ◦   Buffer 类的 readableBytes() 和 writableBytes() 成员函数应该是 const 吗？为什么？

    ◦   如果一个成员函数在逻辑上不修改对象状态，但出于调试目的需要打印日志（修改了 std::cout），它还能声明为 const 吗？为什么？（引出 mutable 关键字）。

二、 面向对象设计与 C++ 特性

1. 继承与多态
•   接口设计：Poller 是一个抽象基类，EpollPoller 继承它。这里使用继承和虚函数（如 poll, updateChannel）的目的是什么？这是一种什么设计模式？（策略模式/多态）。

•   noncopyable 惯用法：noncopyable.h 是如何实现的？（提示：将拷贝构造函数和赋值运算符声明为 private 或 =delete）。C++11 的 =delete 相比传统的 private 声明有什么好处？项目中哪些类继承了它？

•   构造函数与析构函数：

    ◦   为什么 EventLoop 的析构函数需要是平凡的？如果它需要关闭 wakeupFd_，这应该放在哪里做？

    ◦   TcpConnection 的构造函数为什么是 private 的？谁有权限创建 TcpConnection 对象？（提示：friend class TcpServer）。

2. 资源管理（RAII）
•   核心思想：请以 Socket 类为例，解释什么是 RAII（资源获取即初始化）。Socket 类的析构函数做了什么？这如何帮助避免资源（文件描述符）泄漏？

•   文件描述符管理：Socket 对象在构造时获取一个 fd，在析构时关闭它。如果我希望将一个已存在的 fd“移交”给一个 Socket 对象管理（例如在 Acceptor::accept 中创建新连接时），这个 Socket 的构造函数应该如何设计？

三、 模板与泛型编程（考察进阶理解）

1. 模板基础应用
•   隐式使用：项目中没有显式定义很多模板类，但你大量使用了标准库中的模板，比如 std::vector<Channel*>, std::unordered_map<int, TcpConnectionPtr>。你理解这些容器是如何工作的吗？

•   Buffer 中的泛型：Buffer 类有 retrieveInt32(), appendInt32(int32_t x) 这样的函数。如果我想让它支持 int16_t, int64_t 等更多类型，除了重载，有没有更通用的方法？（引出模板成员函数：template<typename T> T readInt() 和 template<typename T> void appendInt(T value)）。需要注意什么？（字节序问题）。

2. 类型推导与 auto
•   现代代码风格：在 EventLoop::loop() 的 for (Channel* activeChannel : activeChannels_) 循环中，能用 auto 代替 Channel* 吗？（可以，auto* 或 auto）。在什么情况下使用 auto 能让代码更清晰？什么情况下应该避免？（当类型名称很长或很复杂时使用 auto 更佳；当类型信息对理解代码至关重要时应避免）。

•   decltype 的理解：虽然项目里可能没用，但可以问：std::function 的类型签名很长。如果我想定义一个和 MessageCallback 同类型的变量，除了直接写 MessageCallback，还能怎么写？（auto cb = ... 或 decltype(messageCallback_) cb）。

四、 并发与多线程（C++ 内存模型与同步）

1. std::thread、std::mutex 与 std::condition_variable
•   线程创建：Thread 类（u3, u11）封装了 std::thread。在 Thread::start() 中，你是如何将线程的执行函数（func_）和 std::thread 对象关联起来的？需要注意 std::thread 的启动时机。

•   互斥锁的使用：在 EventLoop::queueInLoop 中，为什么需要在锁（mutex_）的保护下向 pendingFunctors_ 添加任务？这个锁的粒度是怎样的？

•   std::atomic 的应用：CurrentThread::tid 是一个缓存的线程ID，它被声明为 __thread 或 thread_local。如果我们要用一个全局的原子计数器来统计创建的 TcpConnection 总数，应该用什么类型？为什么？（std::atomic<int>，保证跨线程读写的原子性）。

2. 线程安全与数据竞争
•   无锁设计：EventLoop 的 assertInLoopThread() 是一种“线程断言”，它本身不阻止数据竞争。请分析一下，Channel 对象的 update() 和 remove() 操作是否线程安全？为什么必须要在其所属的 IO 线程中调用？

•   回调的线程环境：用户设置的 messageCallback_ 在哪个线程中被执行？如果用户在这个回调中直接操作了其他线程共享的数据，项目本身提供了保护机制吗？这提醒我们什么？（网络库通常只保证IO相关操作的线程安全，业务数据需要用户自己加锁）。

五、 STL 容器与算法

•   容器的选择：

    ◦   EventLoop 用 std::vector<Channel*> 来存放活跃的 Channel，而 EpollPoller 用 std::unordered_map<int, Channel*> (channels_) 来管理所有注册的 Channel。为什么做这样的选择？（vector 用于临时存放，顺序访问快；unordered_map 用于根据 fd 快速查找）。

    ◦   如果 TcpServer 的 connectionMap_ 需要频繁地根据连接名称进行查找、插入和删除，用 std::unordered_map 是合适的。如果还需要按连接建立时间排序遍历呢？（引出 std::map 的有序性）。

•   算法的使用：在 Buffer::findCRLF() 中，你使用了 std::search 算法。能简单描述一下它的功能吗？如果自己用循环实现，大致思路是什么？

如何使用这份清单：
在面试中，不要问抽象的理论题，而是结合项目中的具体代码提问。例如：
•   不要问：“请说一下 std::shared_ptr 和 std::unique_ptr 的区别。”

•   要这样问：“我在你的 TcpServer.cpp 里看到 connectionMap_ 存储的是 TcpConnectionPtr（shared_ptr）。第 X 行有一个 conn->forceClose() 调用，之后连接对象可能被销毁。你能解释一下，为什么用 shared_ptr 能保证在这里不会出现悬空指针，而用 unique_ptr 就可能会出问题吗？这里的引用计数是如何变化的？”

通过这种方式，你不仅能考察他对 C++ 语法的熟悉程度，更能考察他在实战中运用这些知识解决实际问题的能力，这是区分“知道”和“会用”的关键。